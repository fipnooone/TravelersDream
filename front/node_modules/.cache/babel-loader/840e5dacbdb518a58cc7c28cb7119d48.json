{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport parseDate from '../parseDate';\nimport Integer, { isInteger } from '../../types/Integer';\nimport URL, { isURL } from '../../types/URL';\nimport Email, { isEmail } from '../../types/Email';\nvar DEFAULT_OPTIONS = {\n  isColumnOriented: false\n};\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\n\nexport default function (data, schema, options) {\n  if (options) {\n    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n\n  var _options = options,\n      isColumnOriented = _options.isColumnOriented,\n      rowMap = _options.rowMap;\n  validateSchema(schema);\n\n  if (isColumnOriented) {\n    data = transpose(data);\n  }\n\n  var columns = data[0];\n  var results = [];\n  var errors = [];\n\n  for (var i = 1; i < data.length; i++) {\n    var result = read(schema, data[i], i - 1, columns, errors, options);\n\n    if (result) {\n      results.push(result);\n    }\n  } // Correct error rows.\n\n\n  if (rowMap) {\n    for (var _iterator = _createForOfIteratorHelperLoose(errors), _step; !(_step = _iterator()).done;) {\n      var error = _step.value; // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // The `1` compensates for the header row.\n\n      error.row = rowMap[error.row] + 1;\n    }\n  }\n\n  return {\n    rows: results,\n    errors: errors\n  };\n}\n\nfunction read(schema, row, rowIndex, columns, errors, options) {\n  var object = {};\n\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    var schemaEntry = schema[key];\n    var isNestedSchema = _typeof(schemaEntry.type) === 'object' && !Array.isArray(schemaEntry.type);\n    var rawValue = row[columns.indexOf(key)];\n\n    if (rawValue === undefined) {\n      rawValue = null;\n    }\n\n    var value = void 0;\n    var error = void 0;\n\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options);\n    } else {\n      if (rawValue === null) {\n        value = null;\n      } else if (Array.isArray(schemaEntry.type)) {\n        var notEmpty = false;\n        var array = parseArray(rawValue).map(function (_value) {\n          var result = parseValue(_value, schemaEntry, options);\n\n          if (result.error) {\n            value = _value;\n            error = result.error;\n          }\n\n          if (result.value !== null) {\n            notEmpty = true;\n          }\n\n          return result.value;\n        });\n\n        if (!error) {\n          value = notEmpty ? array : null;\n        }\n      } else {\n        var result = parseValue(rawValue, schemaEntry, options);\n        error = result.error;\n        value = error ? rawValue : result.value;\n      }\n    }\n\n    if (!error && value === null && schemaEntry.required) {\n      error = 'required';\n    }\n\n    if (error) {\n      error = {\n        error: error,\n        row: rowIndex + 1,\n        column: key,\n        value: value\n      };\n\n      if (schemaEntry.type) {\n        error.type = schemaEntry.type;\n      }\n\n      errors.push(error);\n    } else if (value !== null) {\n      object[schemaEntry.prop] = value;\n    }\n  };\n\n  for (var _i = 0, _Object$keys = Object.keys(schema); _i < _Object$keys.length; _i++) {\n    _loop();\n  }\n\n  if (Object.keys(object).length > 0) {\n    return object;\n  }\n\n  return null;\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\n\n\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return {\n      value: null\n    };\n  }\n\n  var result;\n\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse);\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(value, // Supports parsing array types.\n    // See `parseArray()` function for more details.\n    // Example `type`: String[]\n    // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\n    // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n    Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options);\n  } else {\n    result = {\n      value: value\n    }; // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n  } // If errored then return the error.\n\n\n  if (result.error) {\n    return result;\n  }\n\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return {\n        error: 'invalid'\n      };\n    }\n\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value);\n      } catch (error) {\n        return {\n          error: error.message\n        };\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\n\nfunction parseCustomValue(value, parse) {\n  try {\n    value = parse(value);\n\n    if (value === undefined) {\n      return {\n        value: null\n      };\n    }\n\n    return {\n      value: value\n    };\n  } catch (error) {\n    return {\n      error: error.message\n    };\n  }\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\n\n\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      if (typeof value === 'string') {\n        return {\n          value: value\n        };\n      } // The global `isFinite()` function filters out:\n      // * NaN\n      // * -Infinity\n      // * Infinity\n      // All other values pass (including non-numbers).\n\n\n      if (typeof value === 'number') {\n        if (isFinite(value)) {\n          return {\n            value: String(value)\n          };\n        }\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    case Number:\n    case Integer:\n      // Convert strings to numbers.\n      // Just an additional feature.\n      // Won't happen when called from `readXlsx()`.\n      if (typeof value === 'string') {\n        var stringifiedValue = value;\n        value = parseFloat(value);\n\n        if (String(value) !== stringifiedValue) {\n          return {\n            error: 'invalid'\n          };\n        }\n      } else if (typeof value !== 'number') {\n        return {\n          error: 'invalid'\n        };\n      } // The global `isFinite()` function filters out:\n      // * NaN\n      // * -Infinity\n      // * Infinity\n      // All other values pass (including non-numbers).\n      // At this point, `value` can only be a number.\n\n\n      if (!isFinite(value)) {\n        return {\n          error: 'invalid'\n        };\n      }\n\n      if (type === Integer && !isInteger(value)) {\n        return {\n          error: 'invalid'\n        };\n      }\n\n      return {\n        value: value\n      };\n\n    case URL:\n      if (typeof value === 'string') {\n        if (isURL(value)) {\n          return {\n            value: value\n          };\n        }\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    case Email:\n      if (typeof value === 'string') {\n        if (isEmail(value)) {\n          return {\n            value: value\n          };\n        }\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    case Date:\n      // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n      if (value instanceof Date) {\n        return {\n          value: value\n        };\n      }\n\n      if (typeof value === 'number') {\n        if (!isFinite(value)) {\n          return {\n            error: 'invalid'\n          };\n        }\n\n        value = parseInt(value);\n        var date = parseDate(value, options.properties);\n\n        if (!date) {\n          return {\n            error: 'invalid'\n          };\n        }\n\n        return {\n          value: date\n        };\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    case Boolean:\n      if (typeof value === 'boolean') {\n        return {\n          value: value\n        };\n      }\n\n      return {\n        error: 'invalid'\n      };\n\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type);\n      }\n\n      throw new Error(\"Unknown schema type: \".concat(type && type.name || type));\n  }\n}\n\nexport function getBlock(string, endCharacter, startIndex) {\n  var i = 0;\n  var substring = '';\n  var character;\n\n  while (startIndex + i < string.length) {\n    var _character = string[startIndex + i];\n\n    if (_character === endCharacter) {\n      return [substring, i];\n    } else if (_character === '\"') {\n      var block = getBlock(string, '\"', startIndex + i + 1);\n      substring += block[0];\n      i += '\"'.length + block[1] + '\"'.length;\n    } else {\n      substring += _character;\n      i++;\n    }\n  }\n\n  return [substring, i];\n}\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\n\nexport function parseArray(string) {\n  var blocks = [];\n  var index = 0;\n\n  while (index < string.length) {\n    var _getBlock = getBlock(string, ',', index),\n        _getBlock2 = _slicedToArray(_getBlock, 2),\n        substring = _getBlock2[0],\n        length = _getBlock2[1];\n\n    index += length + ','.length;\n    blocks.push(substring.trim());\n  }\n\n  return blocks;\n} // Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\n\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (row) {\n      return row[i];\n    });\n  });\n};\n\nfunction validateSchema(schema) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(schema); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var entry = schema[key];\n\n    if (!entry.prop) {\n      throw new Error(\"\\\"prop\\\" not defined for schema entry \\\"\".concat(key, \"\\\".\"));\n    }\n  }\n}","map":{"version":3,"sources":["../../../source/read/schema/convertToJson.js"],"names":["DEFAULT_OPTIONS","isColumnOriented","options","rowMap","validateSchema","data","transpose","columns","results","errors","i","result","read","error","rows","object","key","Object","schemaEntry","schema","isNestedSchema","Array","rawValue","row","value","notEmpty","array","parseValue","rowIndex","column","parseCustomValue","parseValueOfType","message","parse","isFinite","String","stringifiedValue","parseFloat","type","isInteger","isURL","isEmail","parseInt","date","parseDate","substring","startIndex","string","character","block","getBlock","blocks","index","length","entry"],"mappings":"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","sourcesContent":["import parseDate from '../parseDate'\r\n\r\nimport Integer, { isInteger } from '../../types/Integer'\r\nimport URL, { isURL } from '../../types/URL'\r\nimport Email, { isEmail } from '../../types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // The `1` compensates for the header row.\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      if (typeof value === 'string') {\r\n        return { value }\r\n      }\r\n      // The global `isFinite()` function filters out:\r\n      // * NaN\r\n      // * -Infinity\r\n      // * Infinity\r\n      // All other values pass (including non-numbers).\r\n      if (typeof value === 'number') {\r\n        if (isFinite(value)) {\r\n          return { value: String(value) }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Number:\r\n    case Integer:\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        const stringifiedValue = value\r\n        value = parseFloat(value)\r\n        if (String(value) !== stringifiedValue) {\r\n          return { error: 'invalid' }\r\n        }\r\n      } else if (typeof value !== 'number') {\r\n        return { error: 'invalid' }\r\n      }\r\n      // The global `isFinite()` function filters out:\r\n      // * NaN\r\n      // * -Infinity\r\n      // * Infinity\r\n      // All other values pass (including non-numbers).\r\n      // At this point, `value` can only be a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case URL:\r\n      if (typeof value === 'string') {\r\n        if (isURL(value)) {\r\n          return { value }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Email:\r\n      if (typeof value === 'string') {\r\n        if (isEmail(value)) {\r\n          return { value }\r\n        }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}