{"ast":null,"code":"export function findChild(node, tagName) {\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i]; // `nodeType: 1` means \"Element\".\n    // https://www.w3schools.com/xml/prop_element_nodetype.asp\n\n    if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n      return childNode;\n    }\n\n    i++;\n  }\n}\nexport function findChildren(node, tagName) {\n  var results = [];\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i]; // `nodeType: 1` means \"Element\".\n    // https://www.w3schools.com/xml/prop_element_nodetype.asp\n\n    if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n      results.push(childNode);\n    }\n\n    i++;\n  }\n\n  return results;\n}\nexport function forEach(node, tagName, func) {\n  // if (typeof tagName === 'function') {\n  // \tfunc = tagName\n  // \ttagName = undefined\n  // }\n  var i = 0;\n\n  while (i < node.childNodes.length) {\n    var childNode = node.childNodes[i];\n\n    if (tagName) {\n      // `nodeType: 1` means \"Element\".\n      // https://www.w3schools.com/xml/prop_element_nodetype.asp\n      if (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\n        func(childNode, i);\n      }\n    } else {\n      func(childNode, i);\n    }\n\n    i++;\n  }\n}\nexport function map(node, tagName, func) {\n  var results = [];\n  forEach(node, tagName, function (node, i) {\n    results.push(func(node, i));\n  });\n  return results;\n}\nvar NAMESPACE_REG_EXP = /.+\\:/;\nexport function getTagName(element) {\n  // For some weird reason, if an element is declared as,\n  // for example, `<x:sheets/>`, then its `.tagName` will be\n  // \"x:sheets\" instead of just \"sheets\".\n  // https://gitlab.com/catamphetamine/read-excel-file/-/issues/25\n  // Its not clear how to tell it to ignore any namespaces\n  // when getting `.tagName`, so just replacing anything\n  // before a colon, if any.\n  return element.tagName.replace(NAMESPACE_REG_EXP, '');\n}","map":{"version":3,"sources":["../../source/xml/dom.js"],"names":["i","node","childNode","getTagName","results","func","forEach","NAMESPACE_REG_EXP","element"],"mappings":"AAAA,OAAO,SAAA,SAAA,CAAA,IAAA,EAAA,OAAA,EAAkC;AACxC,MAAIA,CAAC,GAAL,CAAA;;AACA,SAAOA,CAAC,GAAGC,IAAI,CAAJA,UAAAA,CAAX,MAAA,EAAmC;AAClC,QAAMC,SAAS,GAAGD,IAAI,CAAJA,UAAAA,CADgB,CAChBA,CAAlB,CADkC,CAElC;AACA;;AACA,QAAIC,SAAS,CAATA,QAAAA,KAAAA,CAAAA,IAA4BC,UAAU,CAAVA,SAAU,CAAVA,KAAhC,OAAA,EAAmE;AAClE,aAAA,SAAA;AACA;;AACDH,IAAAA,CAAC;AACD;AACD;AAED,OAAO,SAAA,YAAA,CAAA,IAAA,EAAA,OAAA,EAAqC;AAC3C,MAAMI,OAAO,GAAb,EAAA;AACA,MAAIJ,CAAC,GAAL,CAAA;;AACA,SAAOA,CAAC,GAAGC,IAAI,CAAJA,UAAAA,CAAX,MAAA,EAAmC;AAClC,QAAMC,SAAS,GAAGD,IAAI,CAAJA,UAAAA,CADgB,CAChBA,CAAlB,CADkC,CAElC;AACA;;AACA,QAAIC,SAAS,CAATA,QAAAA,KAAAA,CAAAA,IAA4BC,UAAU,CAAVA,SAAU,CAAVA,KAAhC,OAAA,EAAmE;AAClEC,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,SAAAA;AACA;;AACDJ,IAAAA,CAAC;AACD;;AACD,SAAA,OAAA;AACA;AAED,OAAO,SAAA,OAAA,CAAA,IAAA,EAAA,OAAA,EAAA,IAAA,EAAsC;AAC5C;AACA;AACA;AACA;AACA,MAAIA,CAAC,GAAL,CAAA;;AACA,SAAOA,CAAC,GAAGC,IAAI,CAAJA,UAAAA,CAAX,MAAA,EAAmC;AAClC,QAAMC,SAAS,GAAGD,IAAI,CAAJA,UAAAA,CAAlB,CAAkBA,CAAlB;;AACA,QAAA,OAAA,EAAa;AACZ;AACA;AACA,UAAIC,SAAS,CAATA,QAAAA,KAAAA,CAAAA,IAA4BC,UAAU,CAAVA,SAAU,CAAVA,KAAhC,OAAA,EAAmE;AAClEE,QAAAA,IAAI,CAAA,SAAA,EAAJA,CAAI,CAAJA;AACA;AALF,KAAA,MAMO;AACNA,MAAAA,IAAI,CAAA,SAAA,EAAJA,CAAI,CAAJA;AACA;;AACDL,IAAAA,CAAC;AACD;AACD;AAED,OAAO,SAAA,GAAA,CAAA,IAAA,EAAA,OAAA,EAAA,IAAA,EAAkC;AACxC,MAAMI,OAAO,GAAb,EAAA;AACAE,EAAAA,OAAO,CAAA,IAAA,EAAA,OAAA,EAAgB,UAAA,IAAA,EAAA,CAAA,EAAa;AACnCF,IAAAA,OAAO,CAAPA,IAAAA,CAAaC,IAAI,CAAA,IAAA,EAAjBD,CAAiB,CAAjBA;AADDE,GAAO,CAAPA;AAGA,SAAA,OAAA;AACA;AAED,IAAMC,iBAAiB,GAAvB,MAAA;AACA,OAAO,SAAA,UAAA,CAAA,OAAA,EAA6B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAOC,OAAO,CAAPA,OAAAA,CAAAA,OAAAA,CAAAA,iBAAAA,EAAP,EAAOA,CAAP;AACA","sourcesContent":["export function findChild(node, tagName) {\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\t// `nodeType: 1` means \"Element\".\r\n\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nexport function findChildren(node, tagName) {\r\n\tconst results = []\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\t// `nodeType: 1` means \"Element\".\r\n\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\tresults.push(childNode)\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn results\r\n}\r\n\r\nexport function forEach(node, tagName, func) {\r\n\t// if (typeof tagName === 'function') {\r\n\t// \tfunc = tagName\r\n\t// \ttagName = undefined\r\n\t// }\r\n\tlet i = 0\r\n\twhile (i < node.childNodes.length) {\r\n\t\tconst childNode = node.childNodes[i]\r\n\t\tif (tagName) {\r\n\t\t\t// `nodeType: 1` means \"Element\".\r\n\t\t\t// https://www.w3schools.com/xml/prop_element_nodetype.asp\r\n\t\t\tif (childNode.nodeType === 1 && getTagName(childNode) === tagName) {\r\n\t\t\t\tfunc(childNode, i)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfunc(childNode, i)\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nexport function map(node, tagName, func) {\r\n\tconst results = []\r\n\tforEach(node, tagName, (node, i) => {\r\n\t\tresults.push(func(node, i))\r\n\t})\r\n\treturn results\r\n}\r\n\r\nconst NAMESPACE_REG_EXP = /.+\\:/\r\nexport function getTagName(element) {\r\n\t// For some weird reason, if an element is declared as,\r\n\t// for example, `<x:sheets/>`, then its `.tagName` will be\r\n\t// \"x:sheets\" instead of just \"sheets\".\r\n\t// https://gitlab.com/catamphetamine/read-excel-file/-/issues/25\r\n\t// Its not clear how to tell it to ignore any namespaces\r\n\t// when getting `.tagName`, so just replacing anything\r\n\t// before a colon, if any.\r\n\treturn element.tagName.replace(NAMESPACE_REG_EXP, '')\r\n}"]},"metadata":{},"sourceType":"module"}