{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport parseDate from './parseDate';\nimport { getSharedStrings, getCellValue, getCellInlineStringValue, getCells, getDimensions, getBaseStyles, getCellStyles, getNumberFormats, getWorkbookProperties, getRelationships, getSheets } from '../xml/xlsx'; // Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\n\nvar letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]; // https://hexdocs.pm/xlsxir/number_styles.html\n\nvar BUILT_IN_DATE_NUMBER_FORMAT_IDS = [14, 15, 16, 17, 18, 19, 20, 21, 22, 27, 30, 36, 45, 46, 47, 50, 57]; // \"The minimum viable XLSX reader\"\n// https://www.brendanlong.com/the-minimum-viable-xlsx-reader.html\n\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @param  {number?} options.sheet - Workbook sheet id (`1` by default).\r\n * @param  {string?} options.dateFormat - Date format, e.g. \"mm/dd/yyyy\". Values having this format template set will be parsed as dates.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).\r\n */\n\nexport default function readXlsx(contents, xml) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!options.sheet) {\n    options = _objectSpread({\n      sheet: 1\n    }, options);\n  } // Some Excel editors don't want to use standard naming scheme for sheet files.\n  // https://github.com/tidyverse/readxl/issues/104\n\n\n  var filePaths = parseFilePaths(contents['xl/_rels/workbook.xml.rels'], xml); // Default file path for \"shared strings\": \"xl/sharedStrings.xml\".\n\n  var values = filePaths.sharedStrings ? parseValues(contents[filePaths.sharedStrings], xml) : []; // Default file path for \"styles\": \"xl/styles.xml\".\n\n  var styles = filePaths.styles ? parseStyles(contents[filePaths.styles], xml) : {};\n  var properties = parseProperties(contents['xl/workbook.xml'], xml); // A feature for getting the list of sheets in an Excel file.\n  // https://github.com/catamphetamine/read-excel-file/issues/14\n\n  if (options.getSheets) {\n    return properties.sheets.map(function (_ref) {\n      var name = _ref.name;\n      return {\n        name: name\n      };\n    });\n  } // Find the sheet by name, or take the first one.\n\n\n  var sheetRelationId;\n\n  if (typeof options.sheet === 'number') {\n    var _sheet = properties.sheets[options.sheet - 1];\n    sheetRelationId = _sheet && _sheet.relationId;\n  } else {\n    for (var _iterator = _createForOfIteratorHelperLoose(properties.sheets), _step; !(_step = _iterator()).done;) {\n      var _sheet2 = _step.value;\n\n      if (_sheet2.name === options.sheet) {\n        sheetRelationId = _sheet2.relationId;\n        break;\n      }\n    }\n  } // If the sheet wasn't found then throw an error.\n  // Example: \"xl/worksheets/sheet1.xml\".\n\n\n  if (!sheetRelationId || !filePaths.sheets[sheetRelationId]) {\n    throw createSheetNotFoundError(options.sheet, properties.sheets);\n  } // Parse sheet data.\n\n\n  var sheet = parseSheet(contents[filePaths.sheets[sheetRelationId]], xml, values, styles, properties, options); // If the sheet is empty.\n\n  if (sheet.cells.length === 0) {\n    if (options.properties) {\n      return {\n        data: [],\n        properties: properties\n      };\n    }\n\n    return [];\n  }\n\n  var _sheet$dimensions = _slicedToArray(sheet.dimensions, 2),\n      leftTop = _sheet$dimensions[0],\n      rightBottom = _sheet$dimensions[1];\n\n  var colsCount = rightBottom.column - leftTop.column + 1;\n  var rowsCount = rightBottom.row - leftTop.row + 1; // `sheet.cells` seem to not necessarily be sorted by row and column.\n\n  var data = new Array(rowsCount);\n  var i = 0;\n\n  while (i < rowsCount) {\n    data[i] = new Array(colsCount);\n    var j = 0;\n\n    while (j < colsCount) {\n      data[i][j] = null;\n      j++;\n    }\n\n    i++;\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(sheet.cells), _step2; !(_step2 = _iterator2()).done;) {\n    var cell = _step2.value;\n    var row = cell.row - leftTop.row;\n    var column = cell.column - leftTop.column;\n    data[row][column] = cell.value;\n  } // Fill in the row map.\n\n\n  var _options = options,\n      rowMap = _options.rowMap;\n\n  if (rowMap) {\n    var _i2 = 0;\n\n    while (_i2 < data.length) {\n      rowMap[_i2] = _i2;\n      _i2++;\n    }\n  }\n\n  data = dropEmptyRows(dropEmptyColumns(data, {\n    onlyTrimAtTheEnd: true\n  }), {\n    onlyTrimAtTheEnd: true,\n    rowMap: rowMap\n  });\n\n  if (options.transformData) {\n    data = options.transformData(data); // data = options.transformData(data, {\n    //   dropEmptyRowsAndColumns(data) {\n    //     return dropEmptyRows(dropEmptyColumns(data), { rowMap })\n    //   }\n    // })\n  }\n\n  if (options.properties) {\n    return {\n      data: data,\n      properties: properties\n    };\n  }\n\n  return data;\n}\n\nfunction calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n}\n\nfunction colToInt(col) {\n  // `for ... of ...` would require Babel polyfill for iterating a string.\n  var n = 0;\n  var i = 0;\n\n  while (i < col.length) {\n    n *= 26;\n    n += letters.indexOf(col[i]);\n    i++;\n  }\n\n  return n;\n}\n\nfunction CellCoords(coords) {\n  // Examples: \"AA2091\", \"R988\", \"B1\"\n  coords = coords.split(/(\\d+)/);\n  return [// Row.\n  parseInt(coords[1]), // Column.\n  colToInt(coords[0].trim())];\n} // Example of a `<c/>`ell element:\n//\n// <c>\n//    <f>string</f> — formula.\n//    <v>string</v> — formula pre-computed value.\n//    <is>\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\n//       <r>\n//          <rPr>\n//            ...\n//          </rPr>\n//          <t>string</t>\n//       </r>\n//       <rPh sb=\"1\" eb=\"1\">\n//          <t>string</t>\n//       </rPh>\n//       <phoneticPr fontId=\"1\"/>\n//    </is>\n//    <extLst>\n//       <ext>\n//          <!--any element-->\n//       </ext>\n//    </extLst>\n// </c>\n//\n\n\nfunction Cell(cellNode, sheet, xml, values, styles, properties, options) {\n  var coords = CellCoords(cellNode.getAttribute('r'));\n  var valueElement = getCellValue(sheet, cellNode); // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\n\n  var value = valueElement && valueElement.textContent;\n  var type;\n\n  if (cellNode.hasAttribute('t')) {\n    type = cellNode.getAttribute('t');\n  } else {\n    // Default cell type is \"n\" (numeric).\n    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html\n    type = 'n';\n  } // Available Excel cell types:\n  // https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md\n  //\n  // Some other document (seems to be old):\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html\n  //\n\n\n  switch (type) {\n    // If the cell contains formula string.\n    case 'str':\n      value = value.trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n    // If the cell contains an \"inline\" (not \"shared\") string.\n\n    case 'inlineStr':\n      value = getCellInlineStringValue(cellNode);\n\n      if (value === undefined) {\n        throw new Error(\"Unsupported \\\"inline string\\\" cell value structure: \".concat(cellNode.textContent));\n      }\n\n      value = value.trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n    // If the cell contains a \"shared\" string.\n    // \"Shared\" strings is a way for an Excel editor to reduce\n    // the file size by storing \"commonly used\" strings in a dictionary\n    // and then referring to such strings by their index in that dictionary.\n\n    case 's':\n      // If a cell has no value then there's no `<c/>` element for it.\n      // If a `<c/>` element exists then it's not empty.\n      // The `<v/>`alue is a key in the \"shared strings\" dictionary of the\n      // XLSX file, so look it up in the `values` dictionary by the numeric key.\n      value = values[parseInt(value)];\n      value = value.trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n\n    case 'b':\n      value = value === '1' ? true : false;\n      break;\n    // Stub: blank stub cell that is ignored by data processing utilities.\n\n    case 'z':\n      value = undefined;\n      break;\n    // Error: `value` is a numeric code.\n    // They also wrote: \"and `w` property stores its common name\".\n    // It's unclear what they meant by that.\n\n    case 'e':\n      value = decodeError(value);\n      break;\n    // Date: a string to be parsed as a date.\n    // (usually a string in \"ISO 8601\" format)\n\n    case 'd':\n      if (value === undefined) {\n        break;\n      }\n\n      value = new Date(value);\n      break;\n\n    case 'n':\n      if (value === undefined) {\n        break;\n      }\n\n      value = parseFloat(value); // XLSX does have \"d\" type for dates, but it's not commonly used.\n      //  specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n      //\n      // Format IDs:\n      // https://xlsxwriter.readthedocs.io/format.html#format-set-num-format\n      //\n\n      if (cellNode.hasAttribute('s')) {\n        var styleId = parseInt(cellNode.getAttribute('s'));\n        var style = styles[styleId];\n\n        if (!style) {\n          throw new Error(\"Cell style not found: \".concat(styleId));\n        }\n\n        if (BUILT_IN_DATE_NUMBER_FORMAT_IDS.indexOf(parseInt(style.numberFormat.id)) >= 0 || options.dateFormat && style.numberFormat.template === options.dateFormat || options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template)) {\n          value = parseDate(value, properties);\n        }\n      }\n\n      break;\n\n    default:\n      throw new TypeError(\"Cell type not supported: \".concat(type));\n  } // Convert empty values to `null`.\n\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: value\n  };\n}\n\nexport function dropEmptyRows(data) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      rowMap = _ref2.rowMap,\n      _ref2$accessor = _ref2.accessor,\n      accessor = _ref2$accessor === void 0 ? function (_) {\n    return _;\n  } : _ref2$accessor,\n      onlyTrimAtTheEnd = _ref2.onlyTrimAtTheEnd; // Drop empty rows.\n\n\n  var i = data.length - 1;\n\n  while (i >= 0) {\n    // Check if the row is empty.\n    var empty = true;\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(data[i]), _step3; !(_step3 = _iterator3()).done;) {\n      var cell = _step3.value;\n\n      if (accessor(cell) !== null) {\n        empty = false;\n        break;\n      }\n    } // Remove the empty row.\n\n\n    if (empty) {\n      data.splice(i, 1);\n\n      if (rowMap) {\n        rowMap.splice(i, 1);\n      }\n    } else if (onlyTrimAtTheEnd) {\n      break;\n    }\n\n    i--;\n  }\n\n  return data;\n}\nexport function dropEmptyColumns(data) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$accessor = _ref3.accessor,\n      accessor = _ref3$accessor === void 0 ? function (_) {\n    return _;\n  } : _ref3$accessor,\n      onlyTrimAtTheEnd = _ref3.onlyTrimAtTheEnd;\n\n  var i = data[0].length - 1;\n\n  while (i >= 0) {\n    var empty = true;\n\n    for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done;) {\n      var row = _step4.value;\n\n      if (accessor(row[i]) !== null) {\n        empty = false;\n        break;\n      }\n    }\n\n    if (empty) {\n      var j = 0;\n\n      while (j < data.length) {\n        data[j].splice(i, 1);\n        j++;\n      }\n    } else if (onlyTrimAtTheEnd) {\n      break;\n    }\n\n    i--;\n  }\n\n  return data;\n}\n\nfunction parseSheet(content, xml, values, styles, properties, options) {\n  var sheet = xml.createDocument(content);\n  var cells = getCells(sheet);\n\n  if (cells.length === 0) {\n    return {\n      cells: []\n    };\n  }\n\n  cells = cells.map(function (node) {\n    return Cell(node, sheet, xml, values, styles, properties, options);\n  });\n  var dimensions = getDimensions(sheet);\n\n  if (dimensions) {\n    dimensions = dimensions.split(':').map(CellCoords).map(function (_ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n          row = _ref5[0],\n          column = _ref5[1];\n\n      return {\n        row: row,\n        column: column\n      };\n    }); // When there's only a single cell on a sheet\n    // there can sometimes be just \"A1\" for the dimensions string.\n\n    if (dimensions.length === 1) {\n      dimensions = [dimensions[0], dimensions[0]];\n    }\n  } else {\n    dimensions = calculateDimensions(cells);\n  }\n\n  return {\n    cells: cells,\n    dimensions: dimensions\n  };\n}\n\nfunction parseValues(content, xml) {\n  if (!content) {\n    return [];\n  }\n\n  return getSharedStrings(xml.createDocument(content));\n} // http://officeopenxml.com/SSstyles.php\n// Returns an array of cell styles.\n// A cell style index is its ID.\n\n\nfunction parseStyles(content, xml) {\n  if (!content) {\n    return {};\n  } // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile\n  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/\n\n\n  var doc = xml.createDocument(content);\n  var baseStyles = getBaseStyles(doc).map(parseCellStyle);\n  var numberFormats = getNumberFormats(doc).map(parseNumberFormatStyle).reduce(function (formats, format) {\n    // Format ID is a numeric index.\n    // There're some standard \"built-in\" formats (in Excel) up to about `100`.\n    formats[format.id] = format;\n    return formats;\n  }, []);\n\n  var getCellStyle = function getCellStyle(xf) {\n    if (xf.hasAttribute('xfId')) {\n      return _objectSpread(_objectSpread({}, baseStyles[xf.xfId]), parseCellStyle(xf, numberFormats));\n    }\n\n    return parseCellStyle(xf, numberFormats);\n  };\n\n  return getCellStyles(doc).map(getCellStyle);\n}\n\nfunction parseNumberFormatStyle(numFmt) {\n  return {\n    id: numFmt.getAttribute('numFmtId'),\n    template: numFmt.getAttribute('formatCode')\n  };\n} // http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html\n\n\nfunction parseCellStyle(xf, numFmts) {\n  var style = {};\n\n  if (xf.hasAttribute('numFmtId')) {\n    var numberFormatId = xf.getAttribute('numFmtId'); // Built-in number formats don't have a `<numFmt/>` element in `styles.xml`.\n    // https://hexdocs.pm/xlsxir/number_styles.html\n\n    if (numFmts[numberFormatId]) {\n      style.numberFormat = numFmts[numberFormatId];\n    } else {\n      style.numberFormat = {\n        id: numberFormatId\n      };\n    }\n  }\n\n  return style;\n} // I guess `xl/workbook.xml` file should always be present inside the *.xlsx archive.\n\n\nfunction parseProperties(content, xml) {\n  var book = xml.createDocument(content);\n  var properties = {}; // Read `<workbookPr/>` element to detect whether dates are 1900-based or 1904-based.\n  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html\n\n  var workbookProperties = getWorkbookProperties(book);\n\n  if (workbookProperties && workbookProperties.getAttribute('date1904') === '1') {\n    properties.epoch1904 = true;\n  } // Get sheets info (indexes, names, if they're available).\n  // Example:\n  // <sheets>\n  //   <sheet\n  //     xmlns:ns=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n  //     name=\"Sheet1\"\n  //     sheetId=\"1\"\n  //     ns:id=\"rId3\"/>\n  // </sheets>\n  // http://www.datypic.com/sc/ooxml/e-ssml_sheet-1.html\n\n\n  properties.sheets = [];\n\n  var addSheetInfo = function addSheetInfo(sheet) {\n    if (sheet.getAttribute('name')) {\n      properties.sheets.push({\n        id: sheet.getAttribute('sheetId'),\n        name: sheet.getAttribute('name'),\n        relationId: sheet.getAttribute('r:id')\n      });\n    }\n  };\n\n  getSheets(book).forEach(addSheetInfo);\n  return properties;\n}\n/**\r\n * Returns sheet file paths.\r\n * Seems that the correct place to look for the `sheetId` -> `filename` mapping\r\n * is `xl/_rels/workbook.xml.rels` file.\r\n * https://github.com/tidyverse/readxl/issues/104\r\n * @param  {string} content — `xl/_rels/workbook.xml.rels` file contents.\r\n * @param  {object} xml\r\n * @return {object}\r\n */\n\n\nfunction parseFilePaths(content, xml) {\n  // Example:\n  // <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  //   ...\n  //   <Relationship\n  //     Id=\"rId3\"\n  //     Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"\n  //     Target=\"worksheets/sheet1.xml\"/>\n  // </Relationships>\n  var document = xml.createDocument(content);\n  var filePaths = {\n    sheets: {},\n    sharedStrings: undefined,\n    styles: undefined\n  };\n\n  var addFilePathInfo = function addFilePathInfo(relationship) {\n    var filePath = relationship.getAttribute('Target');\n    var fileType = relationship.getAttribute('Type');\n\n    switch (fileType) {\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles':\n        filePaths.styles = getFilePath(filePath);\n        break;\n\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings':\n        filePaths.sharedStrings = getFilePath(filePath);\n        break;\n\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet':\n        filePaths.sheets[relationship.getAttribute('Id')] = getFilePath(filePath);\n        break;\n    }\n  };\n\n  getRelationships(document).forEach(addFilePathInfo); // Seems like \"sharedStrings.xml\" is not required to exist.\n  // For example, when the spreadsheet doesn't contain any strings.\n  // https://github.com/catamphetamine/read-excel-file/issues/85\n  // if (!filePaths.sharedStrings) {\n  //   throw new Error('\"sharedStrings.xml\" file not found in the *.xlsx file')\n  // }\n\n  return filePaths;\n}\n\nfunction getFilePath(path) {\n  // Normally, `path` is a relative path inside the ZIP archive,\n  // like \"worksheets/sheet1.xml\", or \"sharedStrings.xml\", or \"styles.xml\".\n  // There has been one weird case when file path was an absolute path,\n  // like \"/xl/worksheets/sheet1.xml\" (specifically for sheets):\n  // https://github.com/catamphetamine/read-excel-file/pull/95\n  // Other libraries (like `xlsx`) and software (like Google Docs)\n  // seem to support such absolute file paths, so this library does too.\n  if (path[0] === '/') {\n    return path.slice('/'.length);\n  } // // Seems like a path could also be a URL.\n  // // http://officeopenxml.com/anatomyofOOXML-xlsx.php\n  // if (/^[a-z]+\\:\\/\\//.test(path)) {\n  //   return path\n  // }\n\n\n  return 'xl/' + path;\n}\n\nfunction isDateTemplate(template) {\n  var tokens = template.split(/\\W+/);\n\n  for (var _iterator5 = _createForOfIteratorHelperLoose(tokens), _step5; !(_step5 = _iterator5()).done;) {\n    var token = _step5.value;\n\n    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createSheetNotFoundError(sheet, sheets) {\n  var sheetsList = sheets && sheets.map(function (sheet, i) {\n    return \"\\\"\".concat(sheet.name, \"\\\" (#\").concat(i + 1, \")\");\n  }).join(', ');\n  return new Error(\"Sheet \".concat(typeof sheet === 'number' ? '#' + sheet : '\"' + sheet + '\"', \" not found in the *.xlsx file.\").concat(sheets ? ' Available sheets: ' + sheetsList + '.' : ''));\n} // Decodes numeric error code to a string code.\n// https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md\n\n\nfunction decodeError(errorCode) {\n  // While the error values are determined by the application,\n  // the following are some example error values that could be used:\n  switch (errorCode) {\n    case 0x00:\n      return '#NULL!';\n\n    case 0x07:\n      return '#DIV/0!';\n\n    case 0x0F:\n      return '#VALUE!';\n\n    case 0x17:\n      return '#REF!';\n\n    case 0x1D:\n      return '#NAME?';\n\n    case 0x24:\n      return '#NUM!';\n\n    case 0x2A:\n      return '#N/A';\n\n    case 0x2B:\n      return '#GETTING_DATA';\n\n    default:\n      // Such error code doesn't exist. I made it up.\n      return \"#ERROR_\".concat(errorCode);\n  }\n}","map":{"version":3,"sources":["../../source/read/readXlsx.js"],"names":["letters","BUILT_IN_DATE_NUMBER_FORMAT_IDS","options","sheet","filePaths","parseFilePaths","contents","values","parseValues","styles","parseStyles","properties","parseProperties","name","_sheet","sheetRelationId","createSheetNotFoundError","parseSheet","data","leftTop","rightBottom","colsCount","rowsCount","i","j","cell","row","column","rowMap","dropEmptyRows","dropEmptyColumns","onlyTrimAtTheEnd","comparator","a","allRows","allCols","minRow","maxRow","minCol","maxCol","n","col","coords","parseInt","colToInt","CellCoords","cellNode","valueElement","getCellValue","value","type","getCellInlineStringValue","decodeError","parseFloat","styleId","style","isDateTemplate","parseDate","accessor","empty","xml","cells","getCells","Cell","dimensions","getDimensions","calculateDimensions","getSharedStrings","doc","baseStyles","getBaseStyles","numberFormats","formats","format","getCellStyle","xf","parseCellStyle","getCellStyles","id","numFmt","template","numberFormatId","numFmts","book","workbookProperties","getWorkbookProperties","addSheetInfo","relationId","getSheets","document","sheets","sharedStrings","undefined","addFilePathInfo","filePath","relationship","fileType","getFilePath","getRelationships","path","tokens","token","sheetsList"],"mappings":"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","sourcesContent":["import parseDate from './parseDate'\r\n\r\nimport {\r\n  getSharedStrings,\r\n  getCellValue,\r\n  getCellInlineStringValue,\r\n  getCells,\r\n  getDimensions,\r\n  getBaseStyles,\r\n  getCellStyles,\r\n  getNumberFormats,\r\n  getWorkbookProperties,\r\n  getRelationships,\r\n  getSheets\r\n} from '../xml/xlsx'\r\n\r\n// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\r\nconst letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\r\n\r\n// https://hexdocs.pm/xlsxir/number_styles.html\r\nconst BUILT_IN_DATE_NUMBER_FORMAT_IDS = [14,15,16,17,18,19,20,21,22,27,30,36,45,46,47,50,57]\r\n\r\n// \"The minimum viable XLSX reader\"\r\n// https://www.brendanlong.com/the-minimum-viable-xlsx-reader.html\r\n\r\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @param  {number?} options.sheet - Workbook sheet id (`1` by default).\r\n * @param  {string?} options.dateFormat - Date format, e.g. \"mm/dd/yyyy\". Values having this format template set will be parsed as dates.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).\r\n */\r\nexport default function readXlsx(contents, xml, options = {}) {\r\n  if (!options.sheet) {\r\n    options = {\r\n      sheet: 1,\r\n      ...options\r\n    }\r\n  }\r\n\r\n  // Some Excel editors don't want to use standard naming scheme for sheet files.\r\n  // https://github.com/tidyverse/readxl/issues/104\r\n  const filePaths = parseFilePaths(contents['xl/_rels/workbook.xml.rels'], xml)\r\n\r\n  // Default file path for \"shared strings\": \"xl/sharedStrings.xml\".\r\n  const values = filePaths.sharedStrings\r\n    ? parseValues(contents[filePaths.sharedStrings], xml)\r\n    : []\r\n\r\n  // Default file path for \"styles\": \"xl/styles.xml\".\r\n  const styles = filePaths.styles\r\n    ? parseStyles(contents[filePaths.styles], xml)\r\n    : {}\r\n\r\n  const properties = parseProperties(contents['xl/workbook.xml'], xml)\r\n\r\n  // A feature for getting the list of sheets in an Excel file.\r\n  // https://github.com/catamphetamine/read-excel-file/issues/14\r\n  if (options.getSheets) {\r\n    return properties.sheets.map(({ name }) => ({\r\n      name\r\n    }))\r\n  }\r\n\r\n  // Find the sheet by name, or take the first one.\r\n  let sheetRelationId\r\n  if (typeof options.sheet === 'number') {\r\n    const _sheet = properties.sheets[options.sheet - 1]\r\n    sheetRelationId = _sheet && _sheet.relationId\r\n  } else {\r\n    for (const sheet of properties.sheets) {\r\n      if (sheet.name === options.sheet) {\r\n        sheetRelationId = sheet.relationId\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // If the sheet wasn't found then throw an error.\r\n  // Example: \"xl/worksheets/sheet1.xml\".\r\n  if (!sheetRelationId || !filePaths.sheets[sheetRelationId]) {\r\n    throw createSheetNotFoundError(options.sheet, properties.sheets)\r\n  }\r\n\r\n  // Parse sheet data.\r\n  const sheet = parseSheet(\r\n    contents[filePaths.sheets[sheetRelationId]],\r\n    xml,\r\n    values,\r\n    styles,\r\n    properties,\r\n    options\r\n  )\r\n\r\n  // If the sheet is empty.\r\n  if (sheet.cells.length === 0) {\r\n    if (options.properties) {\r\n      return {\r\n        data: [],\r\n        properties\r\n      }\r\n    }\r\n    return []\r\n  }\r\n\r\n  const [ leftTop, rightBottom ] = sheet.dimensions\r\n\r\n  const colsCount = (rightBottom.column - leftTop.column) + 1\r\n  const rowsCount = (rightBottom.row - leftTop.row) + 1\r\n\r\n  // `sheet.cells` seem to not necessarily be sorted by row and column.\r\n  let data = new Array(rowsCount)\r\n  let i = 0\r\n  while (i < rowsCount) {\r\n    data[i] = new Array(colsCount)\r\n    let j = 0\r\n    while (j < colsCount) {\r\n      data[i][j] = null\r\n      j++\r\n    }\r\n    i++\r\n  }\r\n\r\n  for (const cell of sheet.cells) {\r\n    const row = cell.row - leftTop.row\r\n    const column = cell.column - leftTop.column\r\n    data[row][column] = cell.value\r\n  }\r\n\r\n  // Fill in the row map.\r\n  const { rowMap } = options\r\n  if (rowMap) {\r\n    let i = 0\r\n    while (i < data.length) {\r\n      rowMap[i] = i\r\n      i++\r\n    }\r\n  }\r\n\r\n  data = dropEmptyRows(\r\n    dropEmptyColumns(data, { onlyTrimAtTheEnd: true }),\r\n    { onlyTrimAtTheEnd: true, rowMap }\r\n  )\r\n\r\n  if (options.transformData) {\r\n    data = options.transformData(data)\r\n    // data = options.transformData(data, {\r\n    //   dropEmptyRowsAndColumns(data) {\r\n    //     return dropEmptyRows(dropEmptyColumns(data), { rowMap })\r\n    //   }\r\n    // })\r\n  }\r\n\r\n  if (options.properties) {\r\n    return {\r\n      data,\r\n      properties\r\n    }\r\n  }\r\n\r\n  return data\r\n}\r\n\r\nfunction calculateDimensions (cells) {\r\n  const comparator = (a, b) => a - b\r\n  const allRows = cells.map(cell => cell.row).sort(comparator)\r\n  const allCols = cells.map(cell => cell.column).sort(comparator)\r\n  const minRow = allRows[0]\r\n  const maxRow = allRows[allRows.length - 1]\r\n  const minCol = allCols[0]\r\n  const maxCol = allCols[allCols.length - 1]\r\n\r\n  return [\r\n    { row: minRow, column: minCol },\r\n    { row: maxRow, column: maxCol }\r\n  ]\r\n}\r\n\r\nfunction colToInt(col) {\r\n  // `for ... of ...` would require Babel polyfill for iterating a string.\r\n  let n = 0\r\n  let i = 0\r\n  while (i < col.length) {\r\n    n *= 26\r\n    n += letters.indexOf(col[i])\r\n    i++\r\n  }\r\n  return n\r\n}\r\n\r\nfunction CellCoords(coords) {\r\n  // Examples: \"AA2091\", \"R988\", \"B1\"\r\n  coords = coords.split(/(\\d+)/)\r\n  return [\r\n    // Row.\r\n    parseInt(coords[1]),\r\n    // Column.\r\n    colToInt(coords[0].trim())\r\n  ]\r\n}\r\n\r\n// Example of a `<c/>`ell element:\r\n//\r\n// <c>\r\n//    <f>string</f> — formula.\r\n//    <v>string</v> — formula pre-computed value.\r\n//    <is>\r\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\r\n//       <r>\r\n//          <rPr>\r\n//            ...\r\n//          </rPr>\r\n//          <t>string</t>\r\n//       </r>\r\n//       <rPh sb=\"1\" eb=\"1\">\r\n//          <t>string</t>\r\n//       </rPh>\r\n//       <phoneticPr fontId=\"1\"/>\r\n//    </is>\r\n//    <extLst>\r\n//       <ext>\r\n//          <!--any element-->\r\n//       </ext>\r\n//    </extLst>\r\n// </c>\r\n//\r\nfunction Cell(cellNode, sheet, xml, values, styles, properties, options) {\r\n  const coords = CellCoords(cellNode.getAttribute('r'))\r\n\r\n  const valueElement = getCellValue(sheet, cellNode)\r\n\r\n  // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\r\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\r\n  let value = valueElement && valueElement.textContent\r\n\r\n  let type\r\n  if (cellNode.hasAttribute('t')) {\r\n    type = cellNode.getAttribute('t')\r\n  } else {\r\n    // Default cell type is \"n\" (numeric).\r\n    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html\r\n    type = 'n'\r\n  }\r\n\r\n  // Available Excel cell types:\r\n  // https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md\r\n  //\r\n  // Some other document (seems to be old):\r\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html\r\n  //\r\n  switch (type) {\r\n    // If the cell contains formula string.\r\n    case 'str':\r\n      value = value.trim()\r\n      if (value === '') {\r\n        value = undefined\r\n      }\r\n      break\r\n\r\n    // If the cell contains an \"inline\" (not \"shared\") string.\r\n    case 'inlineStr':\r\n      value = getCellInlineStringValue(cellNode)\r\n      if (value === undefined) {\r\n        throw new Error(`Unsupported \"inline string\" cell value structure: ${cellNode.textContent}`)\r\n      }\r\n      value = value.trim()\r\n      if (value === '') {\r\n        value = undefined\r\n      }\r\n      break\r\n\r\n    // If the cell contains a \"shared\" string.\r\n    // \"Shared\" strings is a way for an Excel editor to reduce\r\n    // the file size by storing \"commonly used\" strings in a dictionary\r\n    // and then referring to such strings by their index in that dictionary.\r\n    case 's':\r\n      // If a cell has no value then there's no `<c/>` element for it.\r\n      // If a `<c/>` element exists then it's not empty.\r\n      // The `<v/>`alue is a key in the \"shared strings\" dictionary of the\r\n      // XLSX file, so look it up in the `values` dictionary by the numeric key.\r\n      value = values[parseInt(value)]\r\n      value = value.trim()\r\n      if (value === '') {\r\n        value = undefined\r\n      }\r\n      break\r\n\r\n    case 'b':\r\n      value = value === '1' ? true : false\r\n      break\r\n\r\n    // Stub: blank stub cell that is ignored by data processing utilities.\r\n    case 'z':\r\n      value = undefined\r\n      break\r\n\r\n    // Error: `value` is a numeric code.\r\n    // They also wrote: \"and `w` property stores its common name\".\r\n    // It's unclear what they meant by that.\r\n    case 'e':\r\n      value = decodeError(value)\r\n      break\r\n\r\n    // Date: a string to be parsed as a date.\r\n    // (usually a string in \"ISO 8601\" format)\r\n    case 'd':\r\n      if (value === undefined) {\r\n        break\r\n      }\r\n      value = new Date(value)\r\n      break\r\n\r\n    case 'n':\r\n      if (value === undefined) {\r\n        break\r\n      }\r\n      value = parseFloat(value)\r\n      // XLSX does have \"d\" type for dates, but it's not commonly used.\r\n      //  specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      //\r\n      // Format IDs:\r\n      // https://xlsxwriter.readthedocs.io/format.html#format-set-num-format\r\n      //\r\n      if (cellNode.hasAttribute('s')) {\r\n        const styleId = parseInt(cellNode.getAttribute('s'))\r\n        const style = styles[styleId]\r\n        if (!style) {\r\n          throw new Error(`Cell style not found: ${styleId}`)\r\n        }\r\n        if (BUILT_IN_DATE_NUMBER_FORMAT_IDS.indexOf(parseInt(style.numberFormat.id)) >= 0 ||\r\n          (options.dateFormat && style.numberFormat.template === options.dateFormat) ||\r\n          (options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template))) {\r\n          value = parseDate(value, properties)\r\n        }\r\n      }\r\n      break\r\n\r\n    default:\r\n      throw new TypeError(`Cell type not supported: ${type}`)\r\n  }\r\n\r\n  // Convert empty values to `null`.\r\n  if (value === undefined) {\r\n    value = null\r\n  }\r\n\r\n  return {\r\n    row: coords[0],\r\n    column: coords[1],\r\n    value\r\n  }\r\n}\r\n\r\nexport function dropEmptyRows(data, {\r\n  rowMap,\r\n  accessor = _ => _,\r\n  onlyTrimAtTheEnd\r\n} = {}) {\r\n  // Drop empty rows.\r\n  let i = data.length - 1\r\n  while (i >= 0) {\r\n    // Check if the row is empty.\r\n    let empty = true\r\n    for (const cell of data[i]) {\r\n      if (accessor(cell) !== null) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    // Remove the empty row.\r\n    if (empty) {\r\n      data.splice(i, 1)\r\n      if (rowMap) {\r\n        rowMap.splice(i, 1)\r\n      }\r\n    } else if (onlyTrimAtTheEnd) {\r\n      break\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}\r\n\r\nexport function dropEmptyColumns(data, {\r\n  accessor = _ => _,\r\n  onlyTrimAtTheEnd\r\n} = {}) {\r\n  let i = data[0].length - 1\r\n  while (i >= 0) {\r\n    let empty = true\r\n    for (const row of data) {\r\n      if (accessor(row[i]) !== null) {\r\n        empty = false\r\n        break\r\n      }\r\n    }\r\n    if (empty) {\r\n      let j = 0;\r\n      while (j < data.length) {\r\n        data[j].splice(i, 1)\r\n        j++\r\n      }\r\n    } else if (onlyTrimAtTheEnd) {\r\n      break\r\n    }\r\n    i--\r\n  }\r\n  return data\r\n}\r\n\r\nfunction parseSheet(content, xml, values, styles, properties, options) {\r\n  const sheet = xml.createDocument(content)\r\n\r\n  let cells = getCells(sheet)\r\n\r\n  if (cells.length === 0) {\r\n    return { cells: [] }\r\n  }\r\n\r\n  cells = cells.map((node) => {\r\n    return Cell(node, sheet, xml, values, styles, properties, options)\r\n  })\r\n\r\n  let dimensions = getDimensions(sheet)\r\n  if (dimensions) {\r\n    dimensions = dimensions.split(':').map(CellCoords).map(([row, column]) => ({\r\n      row,\r\n      column\r\n    }))\r\n    // When there's only a single cell on a sheet\r\n    // there can sometimes be just \"A1\" for the dimensions string.\r\n    if (dimensions.length === 1) {\r\n      dimensions = [dimensions[0], dimensions[0]]\r\n    }\r\n  } else {\r\n    dimensions = calculateDimensions(cells)\r\n  }\r\n\r\n  return { cells, dimensions }\r\n}\r\n\r\nfunction parseValues(content, xml) {\r\n  if (!content) {\r\n    return []\r\n  }\r\n  return getSharedStrings(xml.createDocument(content))\r\n}\r\n\r\n// http://officeopenxml.com/SSstyles.php\r\n// Returns an array of cell styles.\r\n// A cell style index is its ID.\r\nfunction parseStyles(content, xml) {\r\n  if (!content) {\r\n    return {}\r\n  }\r\n\r\n  // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile\r\n  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/\r\n  const doc = xml.createDocument(content)\r\n\r\n  const baseStyles = getBaseStyles(doc)\r\n    .map(parseCellStyle)\r\n\r\n  const numberFormats = getNumberFormats(doc)\r\n    .map(parseNumberFormatStyle)\r\n    .reduce((formats, format) => {\r\n      // Format ID is a numeric index.\r\n      // There're some standard \"built-in\" formats (in Excel) up to about `100`.\r\n      formats[format.id] = format\r\n      return formats\r\n    }, [])\r\n\r\n  const getCellStyle = (xf) => {\r\n    if (xf.hasAttribute('xfId')) {\r\n      return {\r\n        ...baseStyles[xf.xfId],\r\n        ...parseCellStyle(xf, numberFormats)\r\n      }\r\n    }\r\n    return parseCellStyle(xf, numberFormats)\r\n  }\r\n\r\n  return getCellStyles(doc).map(getCellStyle)\r\n}\r\n\r\nfunction parseNumberFormatStyle(numFmt) {\r\n  return {\r\n    id: numFmt.getAttribute('numFmtId'),\r\n    template: numFmt.getAttribute('formatCode')\r\n  }\r\n}\r\n\r\n// http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html\r\nfunction parseCellStyle(xf, numFmts) {\r\n  const style = {}\r\n  if (xf.hasAttribute('numFmtId')) {\r\n    const numberFormatId = xf.getAttribute('numFmtId')\r\n    // Built-in number formats don't have a `<numFmt/>` element in `styles.xml`.\r\n    // https://hexdocs.pm/xlsxir/number_styles.html\r\n    if (numFmts[numberFormatId]) {\r\n      style.numberFormat = numFmts[numberFormatId]\r\n    } else {\r\n      style.numberFormat = { id: numberFormatId }\r\n    }\r\n  }\r\n  return style\r\n}\r\n\r\n// I guess `xl/workbook.xml` file should always be present inside the *.xlsx archive.\r\nfunction parseProperties(content, xml) {\r\n  const book = xml.createDocument(content)\r\n\r\n  const properties = {};\r\n\r\n  // Read `<workbookPr/>` element to detect whether dates are 1900-based or 1904-based.\r\n  // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\r\n  // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html\r\n\r\n  const workbookProperties = getWorkbookProperties(book)\r\n\r\n  if (workbookProperties && workbookProperties.getAttribute('date1904') === '1') {\r\n    properties.epoch1904 = true\r\n  }\r\n\r\n  // Get sheets info (indexes, names, if they're available).\r\n  // Example:\r\n  // <sheets>\r\n  //   <sheet\r\n  //     xmlns:ns=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\r\n  //     name=\"Sheet1\"\r\n  //     sheetId=\"1\"\r\n  //     ns:id=\"rId3\"/>\r\n  // </sheets>\r\n  // http://www.datypic.com/sc/ooxml/e-ssml_sheet-1.html\r\n\r\n  properties.sheets = []\r\n\r\n  const addSheetInfo = (sheet) => {\r\n    if (sheet.getAttribute('name')) {\r\n      properties.sheets.push({\r\n        id: sheet.getAttribute('sheetId'),\r\n        name: sheet.getAttribute('name'),\r\n        relationId: sheet.getAttribute('r:id')\r\n      })\r\n    }\r\n  }\r\n\r\n  getSheets(book).forEach(addSheetInfo)\r\n\r\n  return properties;\r\n}\r\n\r\n/**\r\n * Returns sheet file paths.\r\n * Seems that the correct place to look for the `sheetId` -> `filename` mapping\r\n * is `xl/_rels/workbook.xml.rels` file.\r\n * https://github.com/tidyverse/readxl/issues/104\r\n * @param  {string} content — `xl/_rels/workbook.xml.rels` file contents.\r\n * @param  {object} xml\r\n * @return {object}\r\n */\r\nfunction parseFilePaths(content, xml) {\r\n  // Example:\r\n  // <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n  //   ...\r\n  //   <Relationship\r\n  //     Id=\"rId3\"\r\n  //     Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"\r\n  //     Target=\"worksheets/sheet1.xml\"/>\r\n  // </Relationships>\r\n  const document = xml.createDocument(content)\r\n\r\n  const filePaths = {\r\n    sheets: {},\r\n    sharedStrings: undefined,\r\n    styles: undefined\r\n  }\r\n\r\n  const addFilePathInfo = (relationship) => {\r\n    const filePath = relationship.getAttribute('Target')\r\n    const fileType = relationship.getAttribute('Type')\r\n    switch (fileType) {\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles':\r\n        filePaths.styles = getFilePath(filePath)\r\n        break\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings':\r\n        filePaths.sharedStrings = getFilePath(filePath)\r\n        break\r\n      case 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet':\r\n        filePaths.sheets[relationship.getAttribute('Id')] = getFilePath(filePath)\r\n        break\r\n    }\r\n  }\r\n\r\n  getRelationships(document).forEach(addFilePathInfo)\r\n\r\n  // Seems like \"sharedStrings.xml\" is not required to exist.\r\n  // For example, when the spreadsheet doesn't contain any strings.\r\n  // https://github.com/catamphetamine/read-excel-file/issues/85\r\n  // if (!filePaths.sharedStrings) {\r\n  //   throw new Error('\"sharedStrings.xml\" file not found in the *.xlsx file')\r\n  // }\r\n\r\n  return filePaths\r\n}\r\n\r\nfunction getFilePath(path) {\r\n  // Normally, `path` is a relative path inside the ZIP archive,\r\n  // like \"worksheets/sheet1.xml\", or \"sharedStrings.xml\", or \"styles.xml\".\r\n  // There has been one weird case when file path was an absolute path,\r\n  // like \"/xl/worksheets/sheet1.xml\" (specifically for sheets):\r\n  // https://github.com/catamphetamine/read-excel-file/pull/95\r\n  // Other libraries (like `xlsx`) and software (like Google Docs)\r\n  // seem to support such absolute file paths, so this library does too.\r\n  if (path[0] === '/') {\r\n    return path.slice('/'.length)\r\n  }\r\n  // // Seems like a path could also be a URL.\r\n  // // http://officeopenxml.com/anatomyofOOXML-xlsx.php\r\n  // if (/^[a-z]+\\:\\/\\//.test(path)) {\r\n  //   return path\r\n  // }\r\n  return 'xl/' + path\r\n}\r\n\r\nfunction isDateTemplate(template) {\r\n  const tokens = template.split(/\\W+/)\r\n  for (const token of tokens) {\r\n    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction createSheetNotFoundError(sheet, sheets) {\r\n  const sheetsList = sheets && sheets.map((sheet, i) => `\"${sheet.name}\" (#${i + 1})`).join(', ')\r\n  return new Error(`Sheet ${typeof sheet === 'number' ? '#' + sheet : '\"' + sheet + '\"'} not found in the *.xlsx file.${sheets ? ' Available sheets: ' + sheetsList + '.' : ''}`)\r\n}\r\n\r\n// Decodes numeric error code to a string code.\r\n// https://github.com/SheetJS/sheetjs/blob/19620da30be2a7d7b9801938a0b9b1fd3c4c4b00/docbits/52_datatype.md\r\nfunction decodeError(errorCode) {\r\n  // While the error values are determined by the application,\r\n  // the following are some example error values that could be used:\r\n  switch (errorCode) {\r\n    case 0x00:\r\n      return '#NULL!'\r\n    case 0x07:\r\n      return '#DIV/0!'\r\n    case 0x0F:\r\n      return '#VALUE!'\r\n    case 0x17:\r\n      return '#REF!'\r\n    case 0x1D:\r\n      return '#NAME?'\r\n    case 0x24:\r\n      return '#NUM!'\r\n    case 0x2A:\r\n      return '#N/A'\r\n    case 0x2B:\r\n      return '#GETTING_DATA'\r\n    default:\r\n      // Such error code doesn't exist. I made it up.\r\n      return `#ERROR_${errorCode}`\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}